@title Erlang bindings for ZeroMQ messaging framework.

@author Serge Aleynikov <saleyn at gmail dot com>
@author Dhammika Pathirana <dhammika at gmail dot com>
@author Chris Rempel <csrl at gmx dot com>

@copyright 2010 Serge Aleynikov and Dhammika Pathirana, 2011 Chris Rempel

@version {@version}

@doc

<ol>
<li>{@section Overview}</li>
<li>{@section Downloading}</li>
<li>{@section Building}</li>
<li>{@section Issue Tracking}</li>
<li>{@section Contributing}</li>
<li>{@section Architecture}</li>
<li>{@section Known Limitations}</li>
<li>{@section Usage}</li>
<li>{@section License}</li>
</ol>

== Overview ==

ZeroMQ is an open-source fast middleware messaging framework supporting
unicast and multicast communications between peers using various convenient
design patterns.  This project aims at interoperability of Erlang with other
ZeroMQ distributed clients that may be written in other languages.

ZeroMQ project is found here: [http://zeromq.org]

== Downloading ==

Project location and git repository:
<ul>
<li>[http://github.com/zeromq/erlzmq]</li>
<li>`git clone http://github.com/zeromq/erlzmq.git'</li>
</ul>

== Building ==

Obtain and build the latest version of zeromq (at least 2.1.0):

[http://github.com/zeromq/zeromq2]

```
  # Get and build 0MQ project

  $ cd /tmp
  $ git clone http://github.com/zeromq/zeromq2.git
  $ cd /tmp/zeromq2
  $ ./configure
  $ make
  $ make install
'''

Erlzmq project comes with a bootstrap script that uses autotools to create a
configure script.  Below are the steps needed to build erlzmq given the default
location of ZeroMQ installation being `/usr/local':

Make sure that Erlang is installed and `erl' is in the `PATH'. If it's not
in the path, specify `--with-erlang=PATH' option for the configure script.

Run:

```
  $ cd /tmp
  $ git clone http://github.com/zeromq/erlzmq.git
  $ cd /tmp/erlzmq
  $ ./bootstrap
  $ ./configure --with-zeromq=/usr/local
  $ make
  $ make docs
  $ make install
'''

== Issue Tracking ==

[http://github.com/zeromq/erlzmq/issues]

== Contributing ==

When you make any changes to documentation, run the following script to
update documentation on the [http://zeromq.github.com/erlzmq] site:

```
  $ make gitdocs
'''

The following make target can be used to do a cleanup of all artifacts
of make and configure:

```
  $ make clean-bootstrap
'''

== Architecture ==

These erlang bindings offer nearly a direct wrapper around the ZeroMQ C bindings
and as such referencing the ZeroMQ documentation will provide the necessary
information on how to use the `zmq' module api.  The Erlang specific concepts
are documented here.

These bindings are aware of socket ownership by monitoring Erlang pids that
created sockets.  This means that a socket is automatically garbage collected
when the socket owner Erlang pid dies.

`zmq:init/1' initializes a 0MQ Context by starting and linking a gen_server to
the calling process. This server wraps and maintains the initialized 0MQ
Context.  `zmq:init/1' returns the Context which is the Pid of the gen_server.
The Context is used in `zmq:socket/2' and `zmq:term/1'.  The Context may be used
by any erlang process when calling `zmq:socket/2' and not just the Context owner
process.

`zmq:init/2' initializes a named 0MQ Context by starting a named gen_server.
The returned Context is the Pid of the gen_server and can be ignored.  The
context Name can be used as the Context when calling `zmq:socket/2' and
`zmq:term/1'.

`zmq:socket/2' creates a 0MQ Socket by starting and linking a gen_server
to the calling process.  This server wraps and maintains the created 0MQ Socket.
`zmq:socket/2' returns the Socket which is the Pid of the gen_server.  The
Socket is used in the other `zmq' module socket functions.  A Socket may be used
by any erlang process when calling into the `zmq' module and not just the owner
process.

`zmq:send/2' and `zmq:send/3' accept either a binary or a list of binaries.  If
given a list of binaries, then each binary in the list will be sent with
`ZMQ_SNDMORE' except for the last one, which ends the 0MQ message.

`zmq:recv/1' and `zmq:recv/2' will return a binary or a list of binaries.  If
the Socket receives a multi-part message, the entire message will be returned as
a list of binaries.  So there is no need to explicitly check for `ZMQ_RCVMORE'
using `zmq:getsockopt/2' and repeatedly calling `zmq:recv/1' as would be
necessary using the native 0MQ C bindings.

`zmq:poll/2' is non blocking and upon successfully setting up the requested
polling for the Socket, will return `ok'.  When an event on the Socket occurs, a
message will be put in the Socket owner's mailbox having the format of
`{zmq, Socket, Events}' where `Events' is a list having one or both of `pollin'
and `pollout' or if an error occurred, `pollerr'.  Once the event message is
received, `zmq:poll/2' must be called again to receive further events.

`zmq:term/1' is non blocking and fails with EAGAIN if any open Sockets exist for
the given Context.  Ensure all sockets are closed before calling `zmq:term/1'.
If the Context owner process dies, all Sockets in the Context will be forcefully
closed and the Context terminated.

== Known Limitations ==

<ul>
<li>There may be an efficiency issue using many sockets under a single context
    as all sockets share a single erlang port, which is synchronous.  Thus one
    socket's use may block another temporarily.</li>
<li>The Socket gen_server will crash if passed invalid Terms.  Instead this
    should generate the expected errno EINVAL.</li>
</ul>

== Usage ==

=== Sample ZMQ_REQ client ===
```
    % Initialize a ZeroMQ context.
    1> {ok, C} = zmq:init(1).
    {ok,<0.36.0>}

    % Create a ZeroMQ REQ socket.
    2> {ok, S} = zmq:socket(C, req).
    {ok,<0.37.0>}

    % Connect to server
    3> zmq:connect(S, "tcp://127.0.0.1:5555").
    ok

    % Send a message to server
    4> zmq:send(S, <<"Test">>).
    ok

    % Receive a reply
    5> zmq:recv(S).
    {ok,<<"Reply">>}

    % Close socket
    6> zmq:close(S).
    ok

    % Terminate context
    7> zmq:term(C).
    ok
'''

=== Sample ZMQ_REP server ===

Start another shell either within the same Erlang VM
by using ^G, or in a separate OS shell:

```
    % Initialize a ZeroMQ context.
    1> {ok, C} = zmq:init(1).
    {ok,<0.36.0>}

    % Create a ZeroMQ REP socket.
    2> {ok, S} = zmq:socket(C, rep).
    {ok,<0.37.0>}

    % Establish server
    3> zmq:bind(S, "tcp://127.0.0.1:5555").
    ok

    % Receive message from a client
    4> zmq:recv(S).
    {ok,<<"Test">>}

    % Reply to the client
    5> zmq:send(S, <<"Reply">>).
    ok

    % Close socket
    6> zmq:close(S).
    ok

    % Terminate context
    7> zmq:term(C).
    ok
'''

== License ==

The project is released under BSD license.
